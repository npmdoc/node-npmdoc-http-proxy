<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/nodejitsu/node-http-proxy#readme">http-proxy (v1.16.2)</a>
</h1>
<h4>HTTP proxying for the masses</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy">module http-proxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http-proxy">
            function <span class="apidocSignatureSpan"></span>http-proxy
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.createProxy">
            function <span class="apidocSignatureSpan">http-proxy.</span>createProxy
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.createProxyServer">
            function <span class="apidocSignatureSpan">http-proxy.</span>createProxyServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.createServer">
            function <span class="apidocSignatureSpan">http-proxy.</span>createServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy">
            function <span class="apidocSignatureSpan">http-proxy.</span>http_proxy
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_">
            function <span class="apidocSignatureSpan">http-proxy.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http-proxy.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http-proxy.</span>http_proxy.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http-proxy.</span>super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http-proxy.</span>web_incoming</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http-proxy.</span>web_outgoing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http-proxy.</span>ws_incoming</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.common">module http-proxy.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.common.getPort">
            function <span class="apidocSignatureSpan">http-proxy.common.</span>getPort
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.common.hasEncryptedConnection">
            function <span class="apidocSignatureSpan">http-proxy.common.</span>hasEncryptedConnection
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.common.rewriteCookieDomain">
            function <span class="apidocSignatureSpan">http-proxy.common.</span>rewriteCookieDomain
            <span class="apidocSignatureSpan">(header, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.common.setupOutgoing">
            function <span class="apidocSignatureSpan">http-proxy.common.</span>setupOutgoing
            <span class="apidocSignatureSpan">(outgoing, options, req, forward)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.common.setupSocket">
            function <span class="apidocSignatureSpan">http-proxy.common.</span>setupSocket
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.common.urlJoin">
            function <span class="apidocSignatureSpan">http-proxy.common.</span>urlJoin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http-proxy.common.</span>isSSL</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.http_proxy">module http-proxy.http_proxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.http_proxy">
            function <span class="apidocSignatureSpan">http-proxy.</span>http_proxy
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.createProxy">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>createProxy
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.createProxyServer">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>createProxyServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.createServer">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>createServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.super_">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.http_proxy.prototype">module http-proxy.http_proxy.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.prototype.after">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>after
            <span class="apidocSignatureSpan">(type, passName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.prototype.before">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>before
            <span class="apidocSignatureSpan">(type, passName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.prototype.close">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.prototype.listen">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>listen
            <span class="apidocSignatureSpan">(port, hostname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.http_proxy.prototype.onError">
            function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>onError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.super_">module http-proxy.super_</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">http-proxy.super_.</span>prefixed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.super_">
            function <span class="apidocSignatureSpan">http-proxy.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.super_.prototype">module http-proxy.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.addListener">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>addListener
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.emit">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>emit
            <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.eventNames">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.listeners">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>listeners
            <span class="apidocSignatureSpan">(event, exists)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.off">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>off
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.on">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>on
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.once">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.removeListener">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.super_.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.web_incoming">module http-proxy.web_incoming</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_incoming.XHeaders">
            function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>XHeaders
            <span class="apidocSignatureSpan">(req, res, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_incoming.deleteLength">
            function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>deleteLength
            <span class="apidocSignatureSpan">(req, res, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_incoming.stream">
            function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>stream
            <span class="apidocSignatureSpan">(req, res, options, _, server, clb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_incoming.timeout">
            function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>timeout
            <span class="apidocSignatureSpan">(req, res, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.web_outgoing">module http-proxy.web_outgoing</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_outgoing.removeChunked">
            function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>removeChunked
            <span class="apidocSignatureSpan">(req, res, proxyRes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_outgoing.setConnection">
            function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>setConnection
            <span class="apidocSignatureSpan">(req, res, proxyRes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_outgoing.setRedirectHostRewrite">
            function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>setRedirectHostRewrite
            <span class="apidocSignatureSpan">(req, res, proxyRes, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_outgoing.writeHeaders">
            function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>writeHeaders
            <span class="apidocSignatureSpan">(req, res, proxyRes, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.web_outgoing.writeStatusCode">
            function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>writeStatusCode
            <span class="apidocSignatureSpan">(req, res, proxyRes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http-proxy.ws_incoming">module http-proxy.ws_incoming</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.ws_incoming.XHeaders">
            function <span class="apidocSignatureSpan">http-proxy.ws_incoming.</span>XHeaders
            <span class="apidocSignatureSpan">(req, socket, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.ws_incoming.checkMethodAndHeader">
            function <span class="apidocSignatureSpan">http-proxy.ws_incoming.</span>checkMethodAndHeader
            <span class="apidocSignatureSpan">(req, socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http-proxy.ws_incoming.stream">
            function <span class="apidocSignatureSpan">http-proxy.ws_incoming.</span>stream
            <span class="apidocSignatureSpan">(req, socket, options, head, server, clb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy" id="apidoc.module.http-proxy">module http-proxy</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.http-proxy" id="apidoc.element.http-proxy.http-proxy">
        function <span class="apidocSignatureSpan"></span>http-proxy
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyServer(options) {
  EE3.call(this);

  options = options || {};
  options.prependPath = options.prependPath === false ? false : true;

  this.web = this.proxyRequest           = createRightProxy('web')(options);
  this.ws  = this.proxyWebsocketRequest  = createRightProxy('ws')(options);
  this.options = options;

  this.webPasses = Object.keys(web).map(function(pass) {
    return web[pass];
  });

  this.wsPasses = Object.keys(ws).map(function(pass) {
    return ws[pass];
  });

  this.on('error', this.onError, this);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.createProxy" id="apidoc.element.http-proxy.createProxy">
        function <span class="apidocSignatureSpan">http-proxy.</span>createProxy
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProxyServer(options) {
<span class="apidocCodeCommentSpan">  /*
   *  `options` is needed and it must have the following layout:
   *
   *  {
   *    target : &lt;url string to be parsed with the url module&gt;
   *    forward: &lt;url string to be parsed with the url module&gt;
   *    agent  : &lt;object to be passed to http(s).request&gt;
   *    ssl    : &lt;object to be passed to https.createServer()&gt;
   *    ws     : &lt;true/false, if you want to proxy websockets&gt;
   *    xfwd   : &lt;true/false, adds x-forward headers&gt;
   *    secure : &lt;true/false, verify SSL certificate&gt;
   *    toProxy: &lt;true/false, explicitly specify if we are proxying to another proxy&gt;
   *    prependPath: &lt;true/false, Default: true - specify whether you want to prepend the target's path to the proxy path&gt;
   *    ignorePath: &lt;true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request&gt;
   *    localAddress : &lt;Local interface string to bind for outgoing connections&gt;
   *    changeOrigin: &lt;true/false, Default: false - changes the origin of the host header to the target URL&gt;
   *    preserveHeaderKeyCase: &lt;true/false, Default: false - specify whether you want to keep letter case of response header key
 &gt;
   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.
   *    hostRewrite: rewrites the location hostname on (301/302/307/308) redirects, Default: null.
   *    autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false
.
   *    protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.
   *  }
   *
   *  NOTE: `options.ws` and `options.ssl` are optional.
   *    `options.target and `options.forward` cannot be
   *    both missing
   *  }
   */
</span>
  return new ProxyServer(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.createProxyServer" id="apidoc.element.http-proxy.createProxyServer">
        function <span class="apidocSignatureSpan">http-proxy.</span>createProxyServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProxyServer(options) {
<span class="apidocCodeCommentSpan">  /*
   *  `options` is needed and it must have the following layout:
   *
   *  {
   *    target : &lt;url string to be parsed with the url module&gt;
   *    forward: &lt;url string to be parsed with the url module&gt;
   *    agent  : &lt;object to be passed to http(s).request&gt;
   *    ssl    : &lt;object to be passed to https.createServer()&gt;
   *    ws     : &lt;true/false, if you want to proxy websockets&gt;
   *    xfwd   : &lt;true/false, adds x-forward headers&gt;
   *    secure : &lt;true/false, verify SSL certificate&gt;
   *    toProxy: &lt;true/false, explicitly specify if we are proxying to another proxy&gt;
   *    prependPath: &lt;true/false, Default: true - specify whether you want to prepend the target's path to the proxy path&gt;
   *    ignorePath: &lt;true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request&gt;
   *    localAddress : &lt;Local interface string to bind for outgoing connections&gt;
   *    changeOrigin: &lt;true/false, Default: false - changes the origin of the host header to the target URL&gt;
   *    preserveHeaderKeyCase: &lt;true/false, Default: false - specify whether you want to keep letter case of response header key
 &gt;
   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.
   *    hostRewrite: rewrites the location hostname on (301/302/307/308) redirects, Default: null.
   *    autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false
.
   *    protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.
   *  }
   *
   *  NOTE: `options.ws` and `options.ssl` are optional.
   *    `options.target and `options.forward` cannot be
   *    both missing
   *  }
   */
</span>
  return new ProxyServer(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

A new proxy is created by calling `createProxyServer` and passing
an `options` object as argument ([valid properties are available here](lib/http-proxy.js#L33-L50))

```javascript
var httpProxy = require('http-proxy');

var proxy = httpProxy.<span class="apidocCodeKeywordSpan">createProxyServer</span>(options); // See (â€&nbsp;)
```
â€&nbsp;Unless listen(..) is invoked on the object, this does not create a webserver. See below.

An object will be returned with four methods:

* web `req, res, [options]` (used for proxying regular HTTP(S) requests)
* ws `req, socket, head, [options]` (used for proxying WS(S) requests)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.createServer" id="apidoc.element.http-proxy.createServer">
        function <span class="apidocSignatureSpan">http-proxy.</span>createServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProxyServer(options) {
<span class="apidocCodeCommentSpan">  /*
   *  `options` is needed and it must have the following layout:
   *
   *  {
   *    target : &lt;url string to be parsed with the url module&gt;
   *    forward: &lt;url string to be parsed with the url module&gt;
   *    agent  : &lt;object to be passed to http(s).request&gt;
   *    ssl    : &lt;object to be passed to https.createServer()&gt;
   *    ws     : &lt;true/false, if you want to proxy websockets&gt;
   *    xfwd   : &lt;true/false, adds x-forward headers&gt;
   *    secure : &lt;true/false, verify SSL certificate&gt;
   *    toProxy: &lt;true/false, explicitly specify if we are proxying to another proxy&gt;
   *    prependPath: &lt;true/false, Default: true - specify whether you want to prepend the target's path to the proxy path&gt;
   *    ignorePath: &lt;true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request&gt;
   *    localAddress : &lt;Local interface string to bind for outgoing connections&gt;
   *    changeOrigin: &lt;true/false, Default: false - changes the origin of the host header to the target URL&gt;
   *    preserveHeaderKeyCase: &lt;true/false, Default: false - specify whether you want to keep letter case of response header key
 &gt;
   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.
   *    hostRewrite: rewrites the location hostname on (301/302/307/308) redirects, Default: null.
   *    autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false
.
   *    protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.
   *  }
   *
   *  NOTE: `options.ws` and `options.ssl` are optional.
   *    `options.target and `options.forward` cannot be
   *    both missing
   *  }
   */
</span>
  return new ProxyServer(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ws `req, socket, head, [options]` (used for proxying WS(S) requests)
* listen `port` (a function that wraps the object in a webserver, for your convenience)
* close `[callback]` (a function that closes the inner webserver and stops listening on given port)

It is then possible to proxy requests by calling these functions

```javascript
http.<span class="apidocCodeKeywordSpan">createServer</span>(function(req, res) {
  proxy.web(req, res, { target: 'http://mytarget.com:8080' });
});
```

Errors can be listened on either using the Event Emitter API

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy" id="apidoc.element.http-proxy.http_proxy">
        function <span class="apidocSignatureSpan">http-proxy.</span>http_proxy
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyServer(options) {
  EE3.call(this);

  options = options || {};
  options.prependPath = options.prependPath === false ? false : true;

  this.web = this.proxyRequest           = createRightProxy('web')(options);
  this.ws  = this.proxyWebsocketRequest  = createRightProxy('ws')(options);
  this.options = options;

  this.webPasses = Object.keys(web).map(function(pass) {
    return web[pass];
  });

  this.wsPasses = Object.keys(ws).map(function(pass) {
    return ws[pass];
  });

  this.on('error', this.onError, this);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_" id="apidoc.element.http-proxy.super_">
        function <span class="apidocSignatureSpan">http-proxy.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.common" id="apidoc.module.http-proxy.common">module http-proxy.common</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.common.getPort" id="apidoc.element.http-proxy.common.getPort">
        function <span class="apidocSignatureSpan">http-proxy.common.</span>getPort
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPort = function (req) {
  var res = req.headers.host ? req.headers.host.match(/:(\d+)/) : '';

  return res ?
    res[1] :
    common.hasEncryptedConnection(req) ? '443' : '80';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  XHeaders: function XHeaders(req, res, options) {
if(!options.xfwd) return;

var encrypted = req.isSpdy || common.hasEncryptedConnection(req);
var values = {
  for  : req.connection.remoteAddress || req.socket.remoteAddress,
  port : common.<span class="apidocCodeKeywordSpan">getPort</span>(req),
  proto: encrypted ? 'https' : 'http'
};

['for', 'port', 'proto'].forEach(function(header) {
  req.headers['x-forwarded-' + header] =
    (req.headers['x-forwarded-' + header] || '') +
    (req.headers['x-forwarded-' + header] ? ',' : '') +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.common.hasEncryptedConnection" id="apidoc.element.http-proxy.common.hasEncryptedConnection">
        function <span class="apidocSignatureSpan">http-proxy.common.</span>hasEncryptedConnection
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasEncryptedConnection = function (req) {
  return Boolean(req.connection.encrypted || req.connection.pair);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @api private
*/
common.getPort = function(req) {
 var res = req.headers.host ? req.headers.host.match(/:(\d+)/) : '';

 return res ?
   res[1] :
   common.<span class="apidocCodeKeywordSpan">hasEncryptedConnection</span>(req) ? '443' : '80';
};

/**
* Check if the request has an encrypted connection.
*
* @param {Request} req Incoming HTTP request.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.common.rewriteCookieDomain" id="apidoc.element.http-proxy.common.rewriteCookieDomain">
        function <span class="apidocSignatureSpan">http-proxy.common.</span>rewriteCookieDomain
        <span class="apidocSignatureSpan">(header, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rewriteCookieDomain(header, config) {
  if (Array.isArray(header)) {
    return header.map(function (headerElement) {
      return rewriteCookieDomain(headerElement, config);
    });
  }
  return header.replace(cookieDomainRegex, function(match, prefix, previousDomain) {
    var newDomain;
    if (previousDomain in config) {
      newDomain = config[previousDomain];
    } else if ('*' in config) {
      newDomain = config['*'];
    } else {
      //no match, return previous domain
      return match;
    }
    if (newDomain) {
      //replace domain
      return prefix + newDomain;
    } else {
      //remove domain
      return '';
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  writeHeaders: function writeHeaders(req, res, proxyRes, options) {
var rewriteCookieDomainConfig = options.cookieDomainRewrite,
    preserveHeaderKeyCase = options.preserveHeaderKeyCase,
    rawHeaderKeyMap,
    setHeader = function(key, header) {
      if (header == undefined) return;
      if (rewriteCookieDomainConfig &amp;&amp; key.toLowerCase() === 'set-cookie') {
        header = common.<span class="apidocCodeKeywordSpan">rewriteCookieDomain</span>(header, rewriteCookieDomainConfig);
      }
      res.setHeader(String(key).trim(), header);
    };

if (typeof rewriteCookieDomainConfig === 'string') { //also test for ''
  rewriteCookieDomainConfig = { '*': rewriteCookieDomainConfig };
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.common.setupOutgoing" id="apidoc.element.http-proxy.common.setupOutgoing">
        function <span class="apidocSignatureSpan">http-proxy.common.</span>setupOutgoing
        <span class="apidocSignatureSpan">(outgoing, options, req, forward)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupOutgoing = function (outgoing, options, req, forward) {
  outgoing.port = options[forward || 'target'].port ||
                  (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);

  ['host', 'hostname', 'socketPath', 'pfx', 'key',
    'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(
    function(e) { outgoing[e] = options[forward || 'target'][e]; }
  );

  outgoing.method = req.method;
  outgoing.headers = extend({}, req.headers);

  if (options.headers){
    extend(outgoing.headers, options.headers);
  }

  if (options.auth) {
    outgoing.auth = options.auth;
  }

  if (options.ca) {
      outgoing.ca = options.ca;
  }

  if (isSSL.test(options[forward || 'target'].protocol)) {
    outgoing.rejectUnauthorized = (typeof options.secure === "undefined") ? true : options.secure;
  }


  outgoing.agent = options.agent || false;
  outgoing.localAddress = options.localAddress;

  //
  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do
  // as node core doesn't handle this COMPLETELY properly yet.
  //
  if (!outgoing.agent) {
    outgoing.headers = outgoing.headers || {};
    if (typeof outgoing.headers.connection !== 'string'
        || !upgradeHeader.test(outgoing.headers.connection)
       ) { outgoing.headers.connection = 'close'; }
  }


  // the final path is target path + relative path requested by user:
  var target = options[forward || 'target'];
  var targetPath = target &amp;&amp; options.prependPath !== false
    ? (target.path || '')
    : '';

  //
  // Remark: Can we somehow not use url.parse as a perf optimization?
  //
  var outgoingPath = !options.toProxy
    ? (url.parse(req.url).path || '')
    : req.url;

  //
  // Remark: ignorePath will just straight up ignore whatever the request's
  // path is. This can be labeled as FOOT-GUN material if you do not know what
  // you are doing and are using conflicting options.
  //
  outgoingPath = !options.ignorePath ? outgoingPath : '';

  outgoing.path = common.urlJoin(targetPath, outgoingPath);

  if (options.changeOrigin) {
    outgoing.headers.host =
      required(outgoing.port, options[forward || 'target'].protocol) &amp;&amp; !hasPort(outgoing.host)
        ? outgoing.host + ':' + outgoing.port
        : outgoing.host;
  }
  return outgoing;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Copies the right headers from `options` and `req` to
* `outgoing` which is then used to fire the proxied
* request.
*
* Examples:
*
*    common.<span class="apidocCodeKeywordSpan">setupOutgoing</span>(outgoing, options, req)
*    // =&gt; { host: ..., hostname: ...}
*
* @param {Object} Outgoing Base object to be filled with required properties
* @param {Object} Options Config object passed to the proxy
* @param {ClientRequest} Req Request Object
* @param {String} Forward String to select forward or target
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.common.setupSocket" id="apidoc.element.http-proxy.common.setupSocket">
        function <span class="apidocSignatureSpan">http-proxy.common.</span>setupSocket
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupSocket = function (socket) {
  socket.setTimeout(0);
  socket.setNoDelay(true);

  socket.setKeepAlive(true, 0);

  return socket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Set the proper configuration for sockets,
* set no delay and set keep alive, also set
* the timeout to 0.
*
* Examples:
*
*    common.<span class="apidocCodeKeywordSpan">setupSocket</span>(socket)
*    // =&gt; Socket
*
* @param {Socket} Socket instance to setup
*Â&nbsp;
* @return {Socket} Return the configured socket.
*
* @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.common.urlJoin" id="apidoc.element.http-proxy.common.urlJoin">
        function <span class="apidocSignatureSpan">http-proxy.common.</span>urlJoin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlJoin = function () {
    //
    // We do not want to mess with the query string. All we want to touch is the path.
    //
  var args = Array.prototype.slice.call(arguments),
      lastIndex = args.length - 1,
      last = args[lastIndex],
      lastSegs = last.split('?'),
      retSegs;

  args[lastIndex] = lastSegs.shift();

  //
  // Join all strings, but remove empty strings so we don't get extra slashes from
  // joining e.g. ['', 'am']
  //
  retSegs = [
    args.filter(Boolean).join('/')
        .replace(/\/+/g, '/')
        .replace('http:/', 'http://')
        .replace('https:/', 'https://')
  ];

  // Only join the query string if it exists so we don't have trailing a '?'
  // on every request

  // Handle case where there could be multiple ? in the URL.
  retSegs.push.apply(retSegs, lastSegs);

  return retSegs.join('?')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Remark: ignorePath will just straight up ignore whatever the request's
// path is. This can be labeled as FOOT-GUN material if you do not know what
// you are doing and are using conflicting options.
//
outgoingPath = !options.ignorePath ? outgoingPath : '';

outgoing.path = common.<span class="apidocCodeKeywordSpan">urlJoin</span>(targetPath, outgoingPath);

if (options.changeOrigin) {
  outgoing.headers.host =
    required(outgoing.port, options[forward || 'target'].protocol) &amp;&amp; !hasPort(outgoing.host)
      ? outgoing.host + ':' + outgoing.port
      : outgoing.host;
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.http_proxy" id="apidoc.module.http-proxy.http_proxy">module http-proxy.http_proxy</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.http_proxy" id="apidoc.element.http-proxy.http_proxy.http_proxy">
        function <span class="apidocSignatureSpan">http-proxy.</span>http_proxy
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyServer(options) {
  EE3.call(this);

  options = options || {};
  options.prependPath = options.prependPath === false ? false : true;

  this.web = this.proxyRequest           = createRightProxy('web')(options);
  this.ws  = this.proxyWebsocketRequest  = createRightProxy('ws')(options);
  this.options = options;

  this.webPasses = Object.keys(web).map(function(pass) {
    return web[pass];
  });

  this.wsPasses = Object.keys(ws).map(function(pass) {
    return ws[pass];
  });

  this.on('error', this.onError, this);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.createProxy" id="apidoc.element.http-proxy.http_proxy.createProxy">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>createProxy
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProxyServer(options) {
<span class="apidocCodeCommentSpan">  /*
   *  `options` is needed and it must have the following layout:
   *
   *  {
   *    target : &lt;url string to be parsed with the url module&gt;
   *    forward: &lt;url string to be parsed with the url module&gt;
   *    agent  : &lt;object to be passed to http(s).request&gt;
   *    ssl    : &lt;object to be passed to https.createServer()&gt;
   *    ws     : &lt;true/false, if you want to proxy websockets&gt;
   *    xfwd   : &lt;true/false, adds x-forward headers&gt;
   *    secure : &lt;true/false, verify SSL certificate&gt;
   *    toProxy: &lt;true/false, explicitly specify if we are proxying to another proxy&gt;
   *    prependPath: &lt;true/false, Default: true - specify whether you want to prepend the target's path to the proxy path&gt;
   *    ignorePath: &lt;true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request&gt;
   *    localAddress : &lt;Local interface string to bind for outgoing connections&gt;
   *    changeOrigin: &lt;true/false, Default: false - changes the origin of the host header to the target URL&gt;
   *    preserveHeaderKeyCase: &lt;true/false, Default: false - specify whether you want to keep letter case of response header key
 &gt;
   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.
   *    hostRewrite: rewrites the location hostname on (301/302/307/308) redirects, Default: null.
   *    autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false
.
   *    protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.
   *  }
   *
   *  NOTE: `options.ws` and `options.ssl` are optional.
   *    `options.target and `options.forward` cannot be
   *    both missing
   *  }
   */
</span>
  return new ProxyServer(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.createProxyServer" id="apidoc.element.http-proxy.http_proxy.createProxyServer">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>createProxyServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProxyServer(options) {
<span class="apidocCodeCommentSpan">  /*
   *  `options` is needed and it must have the following layout:
   *
   *  {
   *    target : &lt;url string to be parsed with the url module&gt;
   *    forward: &lt;url string to be parsed with the url module&gt;
   *    agent  : &lt;object to be passed to http(s).request&gt;
   *    ssl    : &lt;object to be passed to https.createServer()&gt;
   *    ws     : &lt;true/false, if you want to proxy websockets&gt;
   *    xfwd   : &lt;true/false, adds x-forward headers&gt;
   *    secure : &lt;true/false, verify SSL certificate&gt;
   *    toProxy: &lt;true/false, explicitly specify if we are proxying to another proxy&gt;
   *    prependPath: &lt;true/false, Default: true - specify whether you want to prepend the target's path to the proxy path&gt;
   *    ignorePath: &lt;true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request&gt;
   *    localAddress : &lt;Local interface string to bind for outgoing connections&gt;
   *    changeOrigin: &lt;true/false, Default: false - changes the origin of the host header to the target URL&gt;
   *    preserveHeaderKeyCase: &lt;true/false, Default: false - specify whether you want to keep letter case of response header key
 &gt;
   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.
   *    hostRewrite: rewrites the location hostname on (301/302/307/308) redirects, Default: null.
   *    autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false
.
   *    protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.
   *  }
   *
   *  NOTE: `options.ws` and `options.ssl` are optional.
   *    `options.target and `options.forward` cannot be
   *    both missing
   *  }
   */
</span>
  return new ProxyServer(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

A new proxy is created by calling `createProxyServer` and passing
an `options` object as argument ([valid properties are available here](lib/http-proxy.js#L33-L50))

```javascript
var httpProxy = require('http-proxy');

var proxy = httpProxy.<span class="apidocCodeKeywordSpan">createProxyServer</span>(options); // See (â€&nbsp;)
```
â€&nbsp;Unless listen(..) is invoked on the object, this does not create a webserver. See below.

An object will be returned with four methods:

* web `req, res, [options]` (used for proxying regular HTTP(S) requests)
* ws `req, socket, head, [options]` (used for proxying WS(S) requests)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.createServer" id="apidoc.element.http-proxy.http_proxy.createServer">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>createServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createProxyServer(options) {
<span class="apidocCodeCommentSpan">  /*
   *  `options` is needed and it must have the following layout:
   *
   *  {
   *    target : &lt;url string to be parsed with the url module&gt;
   *    forward: &lt;url string to be parsed with the url module&gt;
   *    agent  : &lt;object to be passed to http(s).request&gt;
   *    ssl    : &lt;object to be passed to https.createServer()&gt;
   *    ws     : &lt;true/false, if you want to proxy websockets&gt;
   *    xfwd   : &lt;true/false, adds x-forward headers&gt;
   *    secure : &lt;true/false, verify SSL certificate&gt;
   *    toProxy: &lt;true/false, explicitly specify if we are proxying to another proxy&gt;
   *    prependPath: &lt;true/false, Default: true - specify whether you want to prepend the target's path to the proxy path&gt;
   *    ignorePath: &lt;true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request&gt;
   *    localAddress : &lt;Local interface string to bind for outgoing connections&gt;
   *    changeOrigin: &lt;true/false, Default: false - changes the origin of the host header to the target URL&gt;
   *    preserveHeaderKeyCase: &lt;true/false, Default: false - specify whether you want to keep letter case of response header key
 &gt;
   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.
   *    hostRewrite: rewrites the location hostname on (301/302/307/308) redirects, Default: null.
   *    autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false
.
   *    protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.
   *  }
   *
   *  NOTE: `options.ws` and `options.ssl` are optional.
   *    `options.target and `options.forward` cannot be
   *    both missing
   *  }
   */
</span>
  return new ProxyServer(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ws `req, socket, head, [options]` (used for proxying WS(S) requests)
* listen `port` (a function that wraps the object in a webserver, for your convenience)
* close `[callback]` (a function that closes the inner webserver and stops listening on given port)

It is then possible to proxy requests by calling these functions

```javascript
http.<span class="apidocCodeKeywordSpan">createServer</span>(function(req, res) {
  proxy.web(req, res, { target: 'http://mytarget.com:8080' });
});
```

Errors can be listened on either using the Event Emitter API

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.super_" id="apidoc.element.http-proxy.http_proxy.super_">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.http_proxy.prototype" id="apidoc.module.http-proxy.http_proxy.prototype">module http-proxy.http_proxy.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.prototype.after" id="apidoc.element.http-proxy.http_proxy.prototype.after">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>after
        <span class="apidocSignatureSpan">(type, passName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">after = function (type, passName, callback) {
  if (type !== 'ws' &amp;&amp; type !== 'web') {
    throw new Error('type must be `web` or `ws`');
  }
  var passes = (type === 'ws') ? this.wsPasses : this.webPasses,
      i = false;

  passes.forEach(function(v, idx) {
    if(v.name === passName) i = idx;
  })

  if(i === false) throw new Error('No such pass');

  passes.splice(i++, 0, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.prototype.before" id="apidoc.element.http-proxy.http_proxy.prototype.before">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>before
        <span class="apidocSignatureSpan">(type, passName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">before = function (type, passName, callback) {
  if (type !== 'ws' &amp;&amp; type !== 'web') {
    throw new Error('type must be `web` or `ws`');
  }
  var passes = (type === 'ws') ? this.wsPasses : this.webPasses,
      i = false;

  passes.forEach(function(v, idx) {
    if(v.name === passName) i = idx;
  })

  if(i === false) throw new Error('No such pass');

  passes.splice(i, 0, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.prototype.close" id="apidoc.element.http-proxy.http_proxy.prototype.close">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  var self = this;
  if (this._server) {
    this._server.close(done);
  }

  // Wrap callback to nullify server after all open connections are closed.
  function done() {
    self._server = null;
    if (callback) {
      callback.apply(null, arguments);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var proxy = new httpProxy.createProxyServer({
  target: {
    host: 'localhost',
    port: 1337
  }
});

proxy.<span class="apidocCodeKeywordSpan">close</span>();
```

**[Back to top](#table-of-contents)**

### Miscellaneous

#### ProxyTable API
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.prototype.listen" id="apidoc.element.http-proxy.http_proxy.prototype.listen">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>listen
        <span class="apidocSignatureSpan">(port, hostname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function (port, hostname) {
  var self    = this,
      closure = function(req, res) { self.web(req, res); };

  this._server  = this.options.ssl ?
    https.createServer(this.options.ssl, closure) :
    http.createServer(closure);

  if(this.options.ws) {
    this._server.on('upgrade', function(req, socket, head) { self.ws(req, socket, head); });
  }

  this._server.listen(port, hostname);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var http = require('http'),
  httpProxy = require('http-proxy');
//
// Create your proxy server and set the target in the options.
//
httpProxy.createProxyServer({target:'http://localhost:9000'}).<span class="apidocCodeKeywordSpan">listen</span>(8000); //
See (â€&nbsp;)

//
// Create your target server
//
http.createServer(function (req, res) {
res.writeHead(200, { 'Content-Type': 'text/plain' });
res.write('request successfully proxied!' + '\n' + JSON.stringify(req.headers, true, 2));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.http_proxy.prototype.onError" id="apidoc.element.http-proxy.http_proxy.prototype.onError">
        function <span class="apidocSignatureSpan">http-proxy.http_proxy.prototype.</span>onError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (err) {
  //
  // Remark: Replicate node core behavior using EE3
  // so we force people to handle their own errors
  //
  if(this.listeners('error').length === 1) {
    throw err;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.super_" id="apidoc.module.http-proxy.super_">module http-proxy.super_</a></h1>




    <h2>
        <a href="#apidoc.element.http-proxy.super_.super_" id="apidoc.element.http-proxy.super_.super_">
        function <span class="apidocSignatureSpan">http-proxy.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.super_.prototype" id="apidoc.module.http-proxy.super_.prototype">module http-proxy.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.addListener" id="apidoc.element.http-proxy.super_.prototype.addListener">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>addListener
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.emit" id="apidoc.element.http-proxy.super_.prototype.emit">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>emit
        <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i &lt; len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i &lt; length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j &lt; len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

['target', 'forward'].forEach(function(e) {
  if (typeof options[e] === 'string')
    options[e] = parse_url(options[e]);
});

if (!options.target &amp;&amp; !options.forward) {
  return this.<span class="apidocCodeKeywordSpan">emit</span>('error', new Error('Must provide a proper URL as target
'));
}

for(var i=0; i &lt; passes.length; i++) {
  /**
   * Call of passes functions
   * pass(req, res, options, head)
   *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.eventNames" id="apidoc.element.http-proxy.super_.prototype.eventNames">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.listeners" id="apidoc.element.http-proxy.super_.prototype.listeners">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>listeners
        <span class="apidocSignatureSpan">(event, exists)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events &amp;&amp; this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i &lt; l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
require('util').inherits(ProxyServer, EE3);

ProxyServer.prototype.onError = function (err) {
//
// Remark: Replicate node core behavior using EE3
// so we force people to handle their own errors
//
if(this.<span class="apidocCodeKeywordSpan">listeners</span>('error').length === 1) {
  throw err;
}
};

ProxyServer.prototype.listen = function(port, hostname) {
var self    = this,
    closure = function(req, res) { self.web(req, res); };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.off" id="apidoc.element.http-proxy.super_.prototype.off">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>off
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &amp;&amp; !listeners.once)
        || (context &amp;&amp; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &lt; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &amp;&amp; !listeners[i].once)
          || (context &amp;&amp; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.on" id="apidoc.element.http-proxy.super_.prototype.on">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>on
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  proxy.web(req, res, { target: 'http://mytarget.com:8080' });
});
```

Errors can be listened on either using the Event Emitter API

```javascript
proxy.<span class="apidocCodeKeywordSpan">on</span>('error', function(e) {
  ...
});
```

or using the callback API

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.once" id="apidoc.element.http-proxy.super_.prototype.once">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.removeAllListeners" id="apidoc.element.http-proxy.super_.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.removeListener" id="apidoc.element.http-proxy.super_.prototype.removeListener">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &amp;&amp; !listeners.once)
        || (context &amp;&amp; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &lt; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &amp;&amp; !listeners[i].once)
          || (context &amp;&amp; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.super_.prototype.setMaxListeners" id="apidoc.element.http-proxy.super_.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">http-proxy.super_.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners() {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.web_incoming" id="apidoc.module.http-proxy.web_incoming">module http-proxy.web_incoming</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.web_incoming.XHeaders" id="apidoc.element.http-proxy.web_incoming.XHeaders">
        function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>XHeaders
        <span class="apidocSignatureSpan">(req, res, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XHeaders(req, res, options) {
  if(!options.xfwd) return;

  var encrypted = req.isSpdy || common.hasEncryptedConnection(req);
  var values = {
    for  : req.connection.remoteAddress || req.socket.remoteAddress,
    port : common.getPort(req),
    proto: encrypted ? 'https' : 'http'
  };

  ['for', 'port', 'proto'].forEach(function(header) {
    req.headers['x-forwarded-' + header] =
      (req.headers['x-forwarded-' + header] || '') +
      (req.headers['x-forwarded-' + header] ? ',' : '') +
      values[header];
  });

  req.headers['x-forwarded-host'] = req.headers['host'] || '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.web_incoming.deleteLength" id="apidoc.element.http-proxy.web_incoming.deleteLength">
        function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>deleteLength
        <span class="apidocSignatureSpan">(req, res, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteLength(req, res, options) {
  if((req.method === 'DELETE' || req.method === 'OPTIONS')
     &amp;&amp; !req.headers['content-length']) {
    req.headers['content-length'] = '0';
    delete req.headers['transfer-encoding'];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.web_incoming.stream" id="apidoc.element.http-proxy.web_incoming.stream">
        function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>stream
        <span class="apidocSignatureSpan">(req, res, options, _, server, clb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stream(req, res, options, _, server, clb) {

  // And we begin!
  server.emit('start', req, res, options.target || options.forward);

  if(options.forward) {
    // If forward enable, so just pipe the request
    var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(
      common.setupOutgoing(options.ssl || {}, options, req, 'forward')
    );

    // error handler (e.g. ECONNRESET, ECONNREFUSED)
    // Handle errors on incoming request as well as it makes sense to
    var forwardError = createErrorHandler(forwardReq, options.forward);
    req.on('error', forwardError);
    forwardReq.on('error', forwardError);

    (options.buffer || req).pipe(forwardReq);
    if(!options.target) { return res.end(); }
  }

  // Request initalization
  var proxyReq = (options.target.protocol === 'https:' ? https : http).request(
    common.setupOutgoing(options.ssl || {}, options, req)
  );

  // Enable developers to modify the proxyReq before headers are sent
  proxyReq.on('socket', function(socket) {
    if(server) { server.emit('proxyReq', proxyReq, req, res, options); }
  });

  // allow outgoing socket to timeout so that we could
  // show an error page at the initial request
  if(options.proxyTimeout) {
    proxyReq.setTimeout(options.proxyTimeout, function() {
       proxyReq.abort();
    });
  }

  // Ensure we abort proxy if request is aborted
  req.on('aborted', function () {
    proxyReq.abort();
  });

  // handle errors in proxy and incoming request, just like for forward proxy
  var proxyError = createErrorHandler(proxyReq, options.target);
  req.on('error', proxyError);
  proxyReq.on('error', proxyError);

  function createErrorHandler(proxyReq, url) {
    return function proxyError(err) {
      if (req.socket.destroyed &amp;&amp; err.code === 'ECONNRESET') {
        server.emit('econnreset', err, req, res, url);
        return proxyReq.abort();
      }

      if (clb) {
        clb(err, req, res, url);
      } else {
        server.emit('error', err, req, res, url);
      }
    }
  }

  (options.buffer || req).pipe(proxyReq);

  proxyReq.on('response', function(proxyRes) {
    if(server) { server.emit('proxyRes', proxyRes, req, res); }
    for(var i=0; i &lt; web_o.length; i++) {
      if(web_o[i](req, res, proxyRes, options)) { break; }
    }

    // Allow us to listen when the proxy has completed
    proxyRes.on('end', function () {
      server.emit('end', req, res, proxyRes);
    });

    proxyRes.pipe(res);
  });

  //proxyReq.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.web_incoming.timeout" id="apidoc.element.http-proxy.web_incoming.timeout">
        function <span class="apidocSignatureSpan">http-proxy.web_incoming.</span>timeout
        <span class="apidocSignatureSpan">(req, res, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(req, res, options) {
  if(options.timeout) {
    req.socket.setTimeout(options.timeout);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.web_outgoing" id="apidoc.module.http-proxy.web_outgoing">module http-proxy.web_outgoing</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.web_outgoing.removeChunked" id="apidoc.element.http-proxy.web_outgoing.removeChunked">
        function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>removeChunked
        <span class="apidocSignatureSpan">(req, res, proxyRes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeChunked(req, res, proxyRes) {
  if (req.httpVersion === '1.0') {
    delete proxyRes.headers['transfer-encoding'];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.web_outgoing.setConnection" id="apidoc.element.http-proxy.web_outgoing.setConnection">
        function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>setConnection
        <span class="apidocSignatureSpan">(req, res, proxyRes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setConnection(req, res, proxyRes) {
  if (req.httpVersion === '1.0') {
    proxyRes.headers.connection = req.headers.connection || 'close';
  } else if (req.httpVersion !== '2.0' &amp;&amp; !proxyRes.headers.connection) {
    proxyRes.headers.connection = req.headers.connection || 'keep-alive';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.web_outgoing.setRedirectHostRewrite" id="apidoc.element.http-proxy.web_outgoing.setRedirectHostRewrite">
        function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>setRedirectHostRewrite
        <span class="apidocSignatureSpan">(req, res, proxyRes, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setRedirectHostRewrite(req, res, proxyRes, options) {
  if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite)
      &amp;&amp; proxyRes.headers['location']
      &amp;&amp; redirectRegex.test(proxyRes.statusCode)) {
    var target = url.parse(options.target);
    var u = url.parse(proxyRes.headers['location']);

    // make sure the redirected host matches the target host before rewriting
    if (target.host != u.host) {
      return;
    }

    if (options.hostRewrite) {
      u.host = options.hostRewrite;
    } else if (options.autoRewrite) {
      u.host = req.headers['host'];
    }
    if (options.protocolRewrite) {
      u.protocol = options.protocolRewrite;
    }

    proxyRes.headers['location'] = u.format();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.web_outgoing.writeHeaders" id="apidoc.element.http-proxy.web_outgoing.writeHeaders">
        function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>writeHeaders
        <span class="apidocSignatureSpan">(req, res, proxyRes, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeHeaders(req, res, proxyRes, options) {
  var rewriteCookieDomainConfig = options.cookieDomainRewrite,
      preserveHeaderKeyCase = options.preserveHeaderKeyCase,
      rawHeaderKeyMap,
      setHeader = function(key, header) {
        if (header == undefined) return;
        if (rewriteCookieDomainConfig &amp;&amp; key.toLowerCase() === 'set-cookie') {
          header = common.rewriteCookieDomain(header, rewriteCookieDomainConfig);
        }
        res.setHeader(String(key).trim(), header);
      };

  if (typeof rewriteCookieDomainConfig === 'string') { //also test for ''
    rewriteCookieDomainConfig = { '*': rewriteCookieDomainConfig };
  }

  // message.rawHeaders is added in: v0.11.6
  // https://nodejs.org/api/http.html#http_message_rawheaders
  if (preserveHeaderKeyCase &amp;&amp; proxyRes.rawHeaders != undefined) {
    rawHeaderKeyMap = {};
    for (var i = 0; i &lt; proxyRes.rawHeaders.length; i += 2) {
      var key = proxyRes.rawHeaders[i];
      rawHeaderKeyMap[key.toLowerCase()] = key;
    }
  }

  Object.keys(proxyRes.headers).forEach(function(key) {
    var header = proxyRes.headers[key];
    if (preserveHeaderKeyCase &amp;&amp; rawHeaderKeyMap) {
      key = rawHeaderKeyMap[key] || key;
    }
    setHeader(key, header);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.web_outgoing.writeStatusCode" id="apidoc.element.http-proxy.web_outgoing.writeStatusCode">
        function <span class="apidocSignatureSpan">http-proxy.web_outgoing.</span>writeStatusCode
        <span class="apidocSignatureSpan">(req, res, proxyRes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeStatusCode(req, res, proxyRes) {
  // From Node.js docs: response.writeHead(statusCode[, statusMessage][, headers])
  if(proxyRes.statusMessage) {
    res.writeHead(proxyRes.statusCode, proxyRes.statusMessage);
  } else {
    res.writeHead(proxyRes.statusCode);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http-proxy.ws_incoming" id="apidoc.module.http-proxy.ws_incoming">module http-proxy.ws_incoming</a></h1>


    <h2>
        <a href="#apidoc.element.http-proxy.ws_incoming.XHeaders" id="apidoc.element.http-proxy.ws_incoming.XHeaders">
        function <span class="apidocSignatureSpan">http-proxy.ws_incoming.</span>XHeaders
        <span class="apidocSignatureSpan">(req, socket, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XHeaders(req, socket, options) {
  if(!options.xfwd) return;

  var values = {
    for  : req.connection.remoteAddress || req.socket.remoteAddress,
    port : common.getPort(req),
    proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'
  };

  ['for', 'port', 'proto'].forEach(function(header) {
    req.headers['x-forwarded-' + header] =
      (req.headers['x-forwarded-' + header] || '') +
      (req.headers['x-forwarded-' + header] ? ',' : '') +
      values[header];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.ws_incoming.checkMethodAndHeader" id="apidoc.element.http-proxy.ws_incoming.checkMethodAndHeader">
        function <span class="apidocSignatureSpan">http-proxy.ws_incoming.</span>checkMethodAndHeader
        <span class="apidocSignatureSpan">(req, socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkMethodAndHeader(req, socket) {
  if (req.method !== 'GET' || !req.headers.upgrade) {
    socket.destroy();
    return true;
  }

  if (req.headers.upgrade.toLowerCase() !== 'websocket') {
    socket.destroy();
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http-proxy.ws_incoming.stream" id="apidoc.element.http-proxy.ws_incoming.stream">
        function <span class="apidocSignatureSpan">http-proxy.ws_incoming.</span>stream
        <span class="apidocSignatureSpan">(req, socket, options, head, server, clb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stream(req, socket, options, head, server, clb) {
  common.setupSocket(socket);

  if (head &amp;&amp; head.length) socket.unshift(head);


  var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(
    common.setupOutgoing(options.ssl || {}, options, req)
  );

  // Enable developers to modify the proxyReq before headers are sent
  if (server) { server.emit('proxyReqWs', proxyReq, req, socket, options, head); }

  // Error Handler
  proxyReq.on('error', onOutgoingError);
  proxyReq.on('response', function (res) {
    // if upgrade event isn't going to happen, close the socket
    if (!res.upgrade) socket.end();
  });

  proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {
    proxySocket.on('error', onOutgoingError);

    // Allow us to listen when the websocket has completed
    proxySocket.on('end', function () {
      server.emit('close', proxyRes, proxySocket, proxyHead);
    });

    // The pipe below will end proxySocket if socket closes cleanly, but not
    // if it errors (eg, vanishes from the net and starts returning
    // EHOSTUNREACH). We need to do that explicitly.
    socket.on('error', function () {
      proxySocket.end();
    });

    common.setupSocket(proxySocket);

    if (proxyHead &amp;&amp; proxyHead.length) proxySocket.unshift(proxyHead);

    //
    // Remark: Handle writing the headers to the socket when switching protocols
    // Also handles when a header is an array
    //
    socket.write(
      Object.keys(proxyRes.headers).reduce(function (head, key) {
        var value = proxyRes.headers[key];

        if (!Array.isArray(value)) {
          head.push(key + ': ' + value);
          return head;
        }

        for (var i = 0; i &lt; value.length; i++) {
          head.push(key + ': ' + value[i]);
        }
        return head;
      }, ['HTTP/1.1 101 Switching Protocols'])
      .join('\r\n') + '\r\n\r\n'
    );

    proxySocket.pipe(socket).pipe(proxySocket);

    server.emit('open', proxySocket);
    server.emit('proxySocket', proxySocket);  //DEPRECATED.
  });

  return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT

  function onOutgoingError(err) {
    if (clb) {
      clb(err, req, socket);
    } else {
      server.emit('error', err, req, socket);
    }
    socket.end();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>